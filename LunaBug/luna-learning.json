[
  {
    "timestamp": "2025-11-03T22:57:46.659Z",
    "errorPattern": "MaxListenersExceededWarning: Possible EventEmitter memory leak detected",
    "errorType": "EVENT_EMITTER",
    "impact": "HIGH",
    "solution": "Increase EventEmitter.defaultMaxListeners and instance.setMaxListeners(50+). Add proper cleanup in shutdown handlers.",
    "codeExample": "EventEmitter.defaultMaxListeners = 20;\nthis.setMaxListeners(50);\n// Add cleanup method with removeAllListeners()",
    "preventionChecks": [
      "Check for EventEmitter usage in classes",
      "Verify cleanup methods exist for graceful shutdown",
      "Monitor listener counts in health checks"
    ]
  },
  {
    "timestamp": "2025-11-03T22:57:46.659Z",
    "errorPattern": "ReferenceError: module is not defined in ES module scope",
    "errorType": "ES_MODULE",
    "impact": "CRITICAL",
    "solution": "Remove CommonJS exports (module.exports) from ES modules. Use only export default/export syntax.",
    "codeExample": "// ‚ùå BAD (CommonJS in ES module)\nmodule.exports = { service };\n\n// ‚úÖ GOOD (ES module only)\nexport default service;\nexport { service };",
    "preventionChecks": [
      "Scan for module.exports in .ts files",
      "Verify package.json has \"type\": \"module\"",
      "Check for require() usage - should be import"
    ]
  },
  {
    "timestamp": "2025-11-03T22:57:46.659Z",
    "errorPattern": "column \"maxEnergy\" does not exist",
    "errorType": "DATABASE_FIELD",
    "impact": "HIGH",
    "solution": "Use correct PostgreSQL column names: energyMax not maxEnergy. Add field validation in MasterDataService.",
    "codeExample": "// ‚ùå BAD\n{ maxEnergy: 1000 }\n\n// ‚úÖ GOOD  \n{ energyMax: 1000 }\n\n// Add validation\nvalidateFieldNaming(data: any) {\n  if ('maxEnergy' in data) {\n    data.energyMax = data.maxEnergy;\n    delete data.maxEnergy;\n  }\n}",
    "preventionChecks": [
      "Validate field names match database schema",
      "Auto-correct common naming mistakes",
      "Use MasterDataService for consistent field naming"
    ]
  },
  {
    "timestamp": "2025-11-03T22:57:46.659Z",
    "errorPattern": "Wrong player JSON directory: using uploads/snapshots instead of main-gamedata/player-data",
    "errorType": "DIRECTORY_STRUCTURE",
    "impact": "HIGH",
    "solution": "Use main-gamedata/player-data/ as primary, uploads/snapshots/ only for backups. File naming: player-{username}.json with telegramId fallback.",
    "codeExample": "// ‚úÖ CORRECT STRUCTURE\nthis.playersDir = path.join(process.cwd(), 'main-gamedata', 'player-data');\nthis.snapshotsDir = path.join(process.cwd(), 'uploads', 'snapshots', 'players');\n\n// ‚úÖ CORRECT NAMING\ngetPlayerFileName(telegramId, username) {\n  return username ? `player-${username.replace(/[^a-zA-Z0-9_-]/g, '_')}.json` : `player-${telegramId}.json`;\n}",
    "preventionChecks": [
      "Verify directory paths use main-gamedata for primary data",
      "Check file naming follows player-{username}.json pattern",
      "Ensure snapshots are backup only, not primary storage"
    ]
  },
  {
    "timestamp": "2025-11-03T22:57:46.659Z",
    "errorPattern": "Character selection API calls failing without proper error handling",
    "errorType": "API_TIMEOUT",
    "impact": "MEDIUM",
    "solution": "Add AbortSignal.timeout() to all API calls, proper error handling with user feedback, and debug logging.",
    "codeExample": "const response = await fetch('/api/endpoint', {\n  signal: AbortSignal.timeout(10000),\n  // ... other options\n});\n\n// Add debug logging\nconsole.log('[ENDPOINT] Request details:', { playerId, data });",
    "preventionChecks": [
      "Add timeout controls to all fetch() calls",
      "Include proper error handling with user feedback",
      "Add debug logging for API operations"
    ]
  },
  {
    "timestamp": "2025-11-03T22:57:46.659Z",
    "errorPattern": "Image loading failures due to malformed URLs or missing files",
    "errorType": "IMAGE_LOADING",
    "impact": "MEDIUM",
    "solution": "Add image error handling with fallback system, placeholder images, and error state tracking.",
    "codeExample": "const [imageErrors, setImageErrors] = useState<Set<string>>(new Set());\n\nconst handleImageError = (url: string) => {\n  setImageErrors(prev => new Set(prev).add(url));\n};\n\n<img onError={() => handleImageError(url)} />",
    "preventionChecks": [
      "Add onError handlers to all img elements",
      "Implement fallback image system",
      "Track failed image URLs to prevent retry loops"
    ]
  },
  {
    "timestamp": "2025-11-05T00:08:43.251Z",
    "incidentId": "ASYNCLOCK_DEADLOCK_NOV_2025",
    "errorPattern": "withTimeout(...) timed out after 5000ms + AsyncLock acquire never resolving",
    "errorType": "ASYNC_LOCK_DEADLOCK",
    "impact": "CRITICAL",
    "debuggingTimeHours": 6,
    "rootCauseModule": "async-lock + proper-lockfile",
    "fixCommitSha": "e0d03409503298b7ae83bcc75cac13b21dd83411",
    "solution": "Complete removal of AsyncLock and proper-lockfile. Direct JSON I/O with background DB sync.",
    "codeExample": "// üö® NEVER USE THIS PATTERN IN JSON-FIRST SYSTEMS:\nclass BadPlayerStateManager {\n  private locks = new Map<string, AsyncLock>();\n  \n  async updatePlayer(playerId: string, updates: any) {\n    const lock = this.getLock(playerId);\n    return await lock.acquire(playerId, async () => { // üíÄ DEADLOCK POINT\n      const release = await lockfile.lock(filePath); // üíÄ HANG POINT\n      // Operations never complete...\n    });\n  }\n}\n\n// ‚úÖ SAFE PATTERN: Direct operations\nclass SafePlayerStateManager {\n  private cache = new Map<string, PlayerState>();\n  \n  async updatePlayer(playerId: string, updates: any) {\n    const current = await this.loadPlayer(playerId);\n    const updated = { ...current, ...updates };\n    \n    // Direct JSON write (atomic)\n    await fs.writeFile(jsonPath, JSON.stringify(updated));\n    this.cache.set(playerId, updated);\n    \n    // DB sync in background (non-blocking)\n    this.syncToDatabase(playerId, updated).catch(console.error);\n    \n    return updated;\n  }\n}",
    "preventionChecks": [
      "NEVER use AsyncLock in player state operations",
      "NEVER use proper-lockfile for JSON persistence",
      "Operations must complete in <1s, not 5s+",
      "Use direct JSON I/O with atomic writes",
      "Database sync must be background/non-blocking",
      "Add timing instrumentation to detect slowdowns",
      "Prefer simple cache + JSON over complex state management"
    ]
  },
  {
    "timestamp": "2025-11-08T01:30:39.003Z",
    "errorPattern": "player/patch: Unexpected token 'T', ...\"isAdmin\": TRUE,\n  \"l\"... is not valid JSON",
    "errorType": "DATABASE_FIELD",
    "impact": "HIGH",
    "solution": "Fixed player/patch with proper error handling and safe defaults",
    "preventionChecks": [
      "Always null-guard player/patch responses",
      "Return complete player objects with defaults"
    ]
  }
]